// @essential-operations @delete @default

// An assignment uses a copy or move assignment operator. In principle, the other cases use a copy or move constructor.
// There are five situations in which an object can be copied or moved:
// As the source of an assignment
// As an object initializer
// As a function argument
// As a function return value
// As an exception

// In addition to the initialization of named objects and 
// of objects on the free store, constructors are used to initialize temporary objects and 
// to implement explicit type conversion.

// Constructors, destructors, and copy and move operations for a type are not logically separate. 
// We must define them as a matched set or suffer logical or performance problems. 
// If a class X has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:
class X {
public:
    X(Sometype);            // "ordinary constructor": create an object
    X();                    // default constructor
    X(const X&);            // copy constructor
    X(X&&);                 // move constructor
    X& operator=(const X&); // copy assignment: clean up target and copy
    X& operator=(X&&);      // move assignment: clean up target and move
    ~X();                   // destructor: clean up
    // ...
};

// A copy or move constructor invocation is often optimized away by constructing the object used to initialize right in the target object. 
// Here, a compiler will typically construct the X from make() directly in x; thus eliminating (“eliding”) a copy.
// Except for the “ordinary constructor,” these special member functions will be generated by the compiler as needed.
X make(Sometype);
X x = make(value);

// If you are explicit about some defaults, other default definitions will not be generated.
class Y {
public:
    Y(Sometype);
    Y(const Y&) = default;   // I really do want the default copy constructor
    Y(Y&&) = default;        // and the default move constructor
    // ...
};

// To complement =default, we have =delete to indicate that an operation is not to be generated.
// A =delete makes an attempted use of the deleted function a compile-time error; 
// =delete can be used to suppress any function, not just essential member functions.
class Shape {
public:
    Shape(const Shape&) =delete; // no copy operations
    Shape& operator=(const Shape&_ =delete;
    // ...
};

void copy(Shape& s1, const Shape& s2)
{
     s1 = s2;  // error: Shape copy is deleted
}

// Here, the compiler will synthesize memberwise default construction, copy, move, and destructor as needed, and all with the correct semantics.
// When a class has a pointer member, it is usually a good idea to be explicit about copy and move operations.
// The reason is that a pointer may point to something that the class needs to delete, in which case the default memberwise copy would be wrong.
// Alternatively, it might point to something that the class must not delete. In either case, a reader of the code would like to know.

// A good rule of thumb (sometimes called the rule of zero) is to either define all of the essential operations or none (using the default for all).
struct Z {
    Vector v;
    string s;
};

// Here, the compiler will synthesize memberwise default construction, copy, move, and destructor as needed, and all with the correct semantics.
Z z1; // default initialize z1.v and z1.s
Z z2 = z1; // default copy z1.v and z1.s
